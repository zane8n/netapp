#!/bin/bash
#
# NetSnmp Library - Core Functions
# Description: Handles configuration, logging, paths, and core utilities.
#

# --- Global Variables ---
# Configuration array, populated by core::load_config
declare -A G_CONFIG
# Paths for config, cache, etc.
declare -A G_PATHS

# Verbosity and debugging flags
G_VERBOSE=false
G_QUIET=false
G_DEBUG=false
VERSION="2.0.0"

# --- Initialization ---

# Initializes all core components of the script
core::init() {
    # Set verbosity levels from arguments
    for arg in "$@"; do
        case "$arg" in
            -q|--quiet) G_QUIET=true ;;
            -v|--verbose) G_VERBOSE=true ;;
            -vv|--debug) G_DEBUG=true; G_VERBOSE=true ;;
        esac
    done
    
    core::setup_paths
    core::load_config
}

# Sets up system or user-specific paths
core::setup_paths() {
    if [[ $EUID -eq 0 ]]; then
        # System-wide paths for root user
        G_PATHS[conf_dir]="/etc/netsnmp"
        G_PATHS[cache_dir]="/var/cache/netsnmp"
        G_PATHS[log_file]="/var/log/netsnmp.log"
    else
        # User-specific paths
        G_PATHS[conf_dir]="${HOME}/.config/netsnmp"
        G_PATHS[cache_dir]="${HOME}/.cache/netsnmp"
        G_PATHS[log_file]="${HOME}/.cache/netsnmp.log"
    fi

    G_PATHS[config_file]="${G_PATHS[conf_dir]}/netsnmp.conf"
    G_PATHS[hosts_cache]="${G_PATHS[cache_dir]}/hosts.cache"
    G_PATHS[ap_cache]="${G_PATHS[cache_dir]}/ap.cache"
}

# Loads configuration from file into the G_CONFIG array
core::load_config() {
    # Set default values
    G_CONFIG=(
        ["subnets"]="192.168.1.0/24"
        ["communities"]="public"
        ["ping_timeout"]="1"
        ["snmp_timeout"]="2"
        ["scan_workers"]="20"
        ["cache_ttl"]="3600"
        ["enable_logging"]="true"
        ["scan_delay"]="0"
    )

    if [[ ! -f "${G_PATHS[config_file]}" ]]; then
        # Don't error out if config is missing, just use defaults
        # The tool should still be searchable if a cache exists.
        return 0
    fi

    # Read config file line by line
    while IFS='=' read -r key value; do
        # Skip comments, empty lines, and malformed lines
        [[ $key =~ ^\s*# ]] || [[ -z $key ]] && continue
        
        # Trim whitespace and remove quotes from key and value
        key=$(echo "$key" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        value=$(echo "$value" | sed -e 's/^[[:space:]]*//; s/[[:space:]]*$//' -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
        
        # Update config array if key is valid
        if [[ -n "${G_CONFIG[$key]+_}" ]]; then
            G_CONFIG["$key"]="$value"
        fi
    done < "${G_PATHS[config_file]}"
    
    core::log_debug "Config loaded from ${G_PATHS[config_file]}"
}

# Saves the current G_CONFIG array to the config file
core::save_config() {
    mkdir -p "${G_PATHS[conf_dir]}"
    
    # Use a temporary file to prevent corruption
    local tmp_file
    tmp_file=$(mktemp)

    cat > "$tmp_file" << EOF
# NetSnmp Configuration File
# Generated by NetSnmp Wizard on $(date)

# Networks to scan (space-separated: CIDR, ranges, single IPs)
# Example: 192.168.1.0/24 10.0.0.1-100 172.16.1.50
subnets="${G_CONFIG[subnets]}"

# SNMP communities to try (space-separated)
# Example: public private read-only
communities="${G_CONFIG[communities]}"

# Timeout for ping checks in seconds.
ping_timeout="${G_CONFIG[ping_timeout]}"

# Timeout for SNMP queries in seconds.
snmp_timeout="${G_CONFIG[snmp_timeout]}"

# Number of parallel processes for scanning.
# Default is 20. Higher values may be faster but can flood the network.
scan_workers="${G_CONFIG[scan_workers]}"

# Time-to-live for cache in seconds (e.g., 3600 = 1 hour).
cache_ttl="${G_CONFIG[cache_ttl]}"

# Delay in milliseconds between scan batches to reduce network noise.
# 0 = disabled. 100 = 100ms delay.
scan_delay="${G_CONFIG[scan_delay]}"

# Enable logging to the log file.
enable_logging="${G_CONFIG[enable_logging]}"
EOF

    # Move temp file to final destination and set permissions
    mv "$tmp_file" "${G_PATHS[config_file]}"
    if [[ $EUID -eq 0 ]]; then
        chmod 644 "${G_PATHS[config_file]}"
    fi
}

# Displays the current configuration
core::show_config() {
    ui::print_header "Current Configuration"
    echo "Config File: ${G_PATHS[config_file]}"
    echo ""
    for key in "${!G_CONFIG[@]}"; do
        printf "  %-18s: %s\n" "$key" "${G_CONFIG[$key]}"
    done
    echo ""
    ui::print_info "To edit, run 'netsnmp --wizard' or manually edit the file."
}


# --- Logging Utilities ---
# These functions now respect the -q (quiet) flag.

core::log() {
    [[ "$G_QUIET" == "true" ]] && return 0
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $*"
    echo "$message" >&2
    
    if [[ "${G_CONFIG[enable_logging]}" == "true" ]]; then
        echo "$message" >> "${G_PATHS[log_file]}" 2>/dev/null || true
    fi
}

core::log_error() {
    # Errors are always shown, regardless of quiet mode
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*"
    echo "$message" >&2
    
    if [[ "${G_CONFIG[enable_logging]}" == "true" ]]; then
        echo "$message" >> "${G_PATHS[log_file]}" 2>/dev/null || true
    fi
}

core::log_debug() {
    [[ "$G_DEBUG" != "true" ]] && return 0
    local timestamp
    timestamp=$(date '+%H:%M:%S')
    echo "[DEBUG ${timestamp}] $*" >&2
}


# --- General Utilities ---

# Checks if a command is available in the system's PATH
core::is_command_available() {
    command -v "$1" &>/dev/null
}